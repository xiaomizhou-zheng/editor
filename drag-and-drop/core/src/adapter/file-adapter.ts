import { bind } from 'bind-event-listener';

import {
  AdapterAPI,
  BaseEventPayload,
  CleanupFn,
  DragInterface,
  DropTargetEventPayloadMap,
  EventPayloadMap,
  ExternalDragType,
  MonitorCanMonitorArgs,
} from '../internal-types';
import { makeAdapter } from '../make-adapter/make-adapter';
import { combine } from '../util/combine';
import { isEnteringWindow } from '../util/entering-and-leaving-the-window';

type FileDragType = ExternalDragType<
  'file',
  'copy',
  {
    items: DataTransfer['items'] | null;
  }
>;

function getFileItems(event: DragEvent): DataTransferItemList | null {
  if (event.dataTransfer == null) {
    return null;
  }
  // filtering out anything that is not a file
  const items = event.dataTransfer.items;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item.kind !== 'file') {
      items.remove(i);
    }
  }
  return items;
}

const adapter = makeAdapter<FileDragType>({
  typeKey: 'file',
  defaultDropEffect: 'copy',
  mount(api: AdapterAPI<FileDragType>): CleanupFn {
    return bind(window, {
      type: 'dragenter',
      listener(event: DragEvent) {
        if (!api.canStart(event)) {
          return;
        }

        // already cancelled by something else
        if (event.defaultPrevented) {
          return;
        }

        if (!isEnteringWindow({ dragEnter: event })) {
          return;
        }

        if (event.dataTransfer == null) {
          return;
        }

        // Checking if we are dragging any files
        // This check works in Chrome, Firefox and Chrome
        if (!event.dataTransfer.types.includes('Files')) {
          return null;
        }

        const dragInterface: DragInterface<FileDragType> = {
          key: 'file',
          startedFrom: 'external',
          payload: {
            // Not giving `.items` initially as it cannot be safely and consistently
            // accessed across browsers
            // Not giving `.types` as the consumer already knows a file is being dragged
            items: null,
          },
          getDropPayload(event: DragEvent): FileDragType['payload'] {
            return {
              items: getFileItems(event),
            };
          },
        };
        api.start({ event, dragInterface });
      },
    });
  },
});

// Some events don't make sense for external files
//
// onGenerateDragPreview: drag preview is always generated by the browser
// type WithoutUselessEvents<T> = Omit<T, 'onDragStart' | 'onGenerateDragPreview'>;
//
// onDragStart: an external file can never start from inside a drop target
// (it will always come from outside and we never let a file drag start in a drop target)
// We remove `onDragStart` from drop targets, but monitors can still listen for a start

type StripEventsForDropTargets<T> = Omit<
  T,
  'onDragStart' | 'onGenerateDragPreview'
>;
type StripPreviewEvent<T> = Omit<T, 'onGenerateDragPreview'>;

export const dropTargetForFiles = (
  args: StripEventsForDropTargets<Parameters<typeof adapter.dropTarget>[0]>,
) => {
  return combine(
    // at least one drop target required before we will start listening for file events
    adapter.registerUsage(),
    // note: not removing unsupported events from args; just leaning on the type system
    adapter.dropTarget(args),
  );
};
export const monitorForFiles = (
  args: StripPreviewEvent<Parameters<typeof adapter.monitor>[0]>,
) => {
  // note: not removing unsupported events from args; just leaning on the type system
  return adapter.monitor(args);
};

export type FileDropTargetEventPayloadMap = StripEventsForDropTargets<
  DropTargetEventPayloadMap<FileDragType>
>;
export type FileEventPayloadMap = StripPreviewEvent<
  EventPayloadMap<FileDragType>
>;
export type FileEventBasePayload = BaseEventPayload<FileDragType>;

export type FileMonitorCanMonitorArgs = MonitorCanMonitorArgs<FileDragType>;
