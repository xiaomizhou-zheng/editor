## API Report File for "@atlaskit/emoji"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

<!--
	Generated API Report version: 2.0
-->

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

```ts
/// <reference types="react" />

import { AbstractResource } from '@atlaskit/util-service-support';
import { Component } from 'react';
import { ComponentClass } from 'react';
import { ComponentType } from 'react';
import { ConcurrentExperience } from '@atlaskit/ufo';
import { CreateUIAnalyticsEvent } from '@atlaskit/analytics-next';
import { FC } from 'react';
import { ForwardRefExoticComponent } from 'react';
import { Provider } from '@atlaskit/util-service-support/types';
import { PureComponent } from 'react';
import { default as React_2 } from 'react';
import { RefAttributes } from 'react';
import { ServiceConfig } from '@atlaskit/util-service-support';
import { SyntheticEvent } from 'react';
import { UFOExperience } from '@atlaskit/ufo';
import { WithAnalyticsEventsProps } from '@atlaskit/analytics-next';

export { AbstractResource };

// @public (undocumented)
export interface AltRepresentations {
  // (undocumented)
  [key: string]: EmojiServiceRepresentation;
}

// @public (undocumented)
interface BaseResourcedEmojiProps {
  customFallback?: JSX.Element | string;
  emojiId: EmojiId;
  fitToHeight?: number;
  optimistic?: boolean;
  optimisticImageURL?: string;
  showTooltip?: boolean;
}

// @public (undocumented)
export interface CategoryDescription {
  // (undocumented)
  icon: any;
  // (undocumented)
  id: string;
  // (undocumented)
  name: keyof typeof messages;
  // (undocumented)
  order: number;
}

// @public (undocumented)
export type CategoryId =
  | 'FREQUENT'
  | 'PEOPLE'
  | 'NATURE'
  | 'FOODS'
  | 'ACTIVITY'
  | 'PLACES'
  | 'OBJECTS'
  | 'SYMBOLS'
  | 'FLAGS'
  | 'ATLASSIAN'
  | 'CUSTOM';

// @public (undocumented)
export const customCategory = 'CUSTOM';

// @public (undocumented)
export const defaultEmojiHeight = 20;

// @public
export const denormaliseEmojiServiceResponse: (
  emojiData: EmojiServiceResponse,
) => EmojiResponse;

// @public
class DuplicateLimitedQueue<T> {
  constructor(options: QueueOptions);
  protected bulkEnqueue(items: T[]): void;
  clear(): void;
  // (undocumented)
  enqueue(item: T): void;
  protected getItems(): T[];
  getItemsOrderedByDuplicateCount(): Array<T>;
}

// @public (undocumented)
export const Emoji: (props: Props) => JSX.Element;

// @public (undocumented)
interface EmojiContext {
  // (undocumented)
  emoji: {
    emojiProvider: EmojiProvider;
  };
}

// @public (undocumented)
export const EmojiContextProvider: FC<EmojiContextProviderType>;

// @public (undocumented)
type EmojiContextProviderType = {
  emojiContextValue: EmojiContextType;
};

// @public (undocumented)
type EmojiContextType = EmojiContext | null;

// @public (undocumented)
export interface EmojiDescription extends EmojiId {
  // (undocumented)
  altRepresentation?: EmojiRepresentation;
  // (undocumented)
  ascii?: string[];
  // (undocumented)
  category: string;
  // (undocumented)
  createdDate?: string;
  // (undocumented)
  creatorUserId?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  order?: number;
  // (undocumented)
  representation: EmojiRepresentation;
  // (undocumented)
  searchable: boolean;
  // (undocumented)
  type: string;
}

// @public (undocumented)
export interface EmojiDescriptionWithVariations extends EmojiDescription {
  // (undocumented)
  skinVariations?: EmojiDescription[];
}

// @public
export interface EmojiId {
  // (undocumented)
  fallback?: string;
  // (undocumented)
  id?: string;
  // (undocumented)
  shortName: string;
}

// @public (undocumented)
export const EmojiImage: FC<EmojiImageType>;

// @public (undocumented)
export const emojiImage = 'emoji-common-emoji-image';

// @public (undocumented)
export interface EmojiImageRepresentation {
  // (undocumented)
  height: number;
  // (undocumented)
  width: number;
}

// @public (undocumented)
type EmojiImageType = {
  emojiId: EmojiId;
  imageUrl: string;
  showImageBeforeLoad?: boolean;
  maxSize?: number;
  representation?: EmojiImageRepresentation;
  showTooltip?: boolean;
  onImageLoadError?: () => void;
};

// @public
export class EmojiLoader {
  constructor(config: EmojiLoaderConfig);
  loadEmoji(): Promise<EmojiResponse>;
}

// @public (undocumented)
interface EmojiLoaderConfig extends ServiceConfig {
  // (undocumented)
  getRatio?: () => number;
}

// @public (undocumented)
export interface EmojiMeta {
  // (undocumented)
  mediaApiToken?: MediaApiToken;
  // (undocumented)
  spriteSheets?: SpriteSheets;
}

// @public (undocumented)
export const emojiNode = 'emoji-common-node';

// @public (undocumented)
const EmojiPicker: ForwardRefExoticComponent<
  Omit<Props_3 & WithAnalyticsEventsProps, keyof WithAnalyticsEventsProps> &
    RefAttributes<any>
>;
export { EmojiPicker };
export default EmojiPicker;

// @public (undocumented)
export const emojiPickerHeight = 295;

// @public (undocumented)
export const emojiPickerWidth = 350;

// @public (undocumented)
export const EmojiPlaceholder: (props: Props_2) => JSX.Element;

// @public (undocumented)
export const emojiPlaceholder = 'emoji-common-placeholder';

// @public (undocumented)
interface EmojiProgessCallback {
  // (undocumented)
  (progress: EmojiProgress): void;
}

// @public (undocumented)
interface EmojiProgress {
  // (undocumented)
  readonly percent: number;
}

// @public (undocumented)
export interface EmojiProvider
  extends Provider<string, EmojiSearchResult, any, undefined, SearchOptions> {
  calculateDynamicCategories?(): Promise<string[]>;
  deleteSiteEmoji(emoji: EmojiDescription): Promise<boolean>;
  fetchEmojiProvider(force?: boolean): Promise<EmojiRepository | undefined>;
  findByEmojiId(
    emojiId: EmojiId,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  findById(
    id: string,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  findByShortName(
    shortName: string,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  findInCategory(categoryId: string): Promise<EmojiDescription[]>;
  getAsciiMap(): Promise<Map<string, EmojiDescription>>;
  getCurrentUser(): OptionalUser;
  getFrequentlyUsed(options?: SearchOptions): Promise<EmojiDescription[]>;
  getMediaEmojiDescriptionURLWithInlineToken(
    emoji: EmojiDescription,
  ): Promise<EmojiDescription>;
  getOptimisticImageURL(emojiId: EmojiId): string | undefined;
  getSelectedTone(): ToneSelection;
  loadMediaEmoji(
    emoji: EmojiDescription,
    useAlt?: boolean,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  optimisticMediaRendering(emoji: EmojiDescription, useAlt?: boolean): boolean;
  recordSelection?(emoji: EmojiDescription): Promise<any>;
  setSelectedTone(tone: ToneSelection): void;
}

// @public (undocumented)
export class EmojiRepository {
  constructor(emojis: EmojiDescription[], usageTracker?: UsageFrequencyTracker);
  // (undocumented)
  addUnknownEmoji(emoji: EmojiDescription): void;
  all(): EmojiSearchResult;
  // (undocumented)
  delete(emoji: EmojiDescription): void;
  findAllMatchingShortName(shortName: string): EmojiDescription[];
  // (undocumented)
  findByAsciiRepresentation(asciiEmoji: string): OptionalEmojiDescription;
  findById(id: string): OptionalEmojiDescription;
  findByShortName(shortName: string): OptionalEmojiDescription;
  // (undocumented)
  findInCategory(categoryId: CategoryId): EmojiDescription[];
  // (undocumented)
  getAsciiMap(): Map<string, EmojiDescription>;
  // (undocumented)
  getDynamicCategoryList(): CategoryId[];
  getFrequentlyUsed(options?: SearchOptions): EmojiDescription[];
  search(query?: string, options?: SearchOptions): EmojiSearchResult;
  // (undocumented)
  protected usageTracker: UsageFrequencyTracker;
  used(emoji: EmojiDescription): void;
}

// @public (undocumented)
export type EmojiRepresentation =
  | SpriteRepresentation
  | ImageRepresentation
  | MediaApiRepresentation
  | undefined;

// @public (undocumented)
export class EmojiResource
  extends EmojiResource_2
  implements UploadingEmojiProvider {
  constructor(config: EmojiResourceConfig);
  // (undocumented)
  protected allowUpload: boolean;
  // (undocumented)
  isUploadSupported(): Promise<boolean>;
  // (undocumented)
  prepareForUpload(): Promise<void>;
  // (undocumented)
  uploadCustomEmoji(
    upload: EmojiUpload,
    retry?: boolean,
  ): Promise<EmojiDescription>;
}

// @public (undocumented)
class EmojiResource_2
  extends AbstractResource<
    string,
    EmojiSearchResult,
    any,
    undefined,
    SearchOptions
  >
  implements EmojiProvider {
  constructor(config: EmojiResourceConfig);
  // (undocumented)
  protected activeLoaders: number;
  // (undocumented)
  protected addUnknownEmoji(emoji: EmojiDescription): void;
  // (undocumented)
  calculateDynamicCategories(): Promise<CategoryId[]>;
  // (undocumented)
  protected currentUser?: User;
  // (undocumented)
  deleteSiteEmoji(emoji: EmojiDescription): Promise<boolean>;
  // (undocumented)
  emojiProviderConfig: EmojiResourceConfig;
  // (undocumented)
  protected emojiRepository?: EmojiRepository;
  // (undocumented)
  fetchByEmojiId(
    emojiId: EmojiId,
    optimistic: boolean,
  ): Promise<OptionalEmojiDescriptionWithVariations>;
  // (undocumented)
  fetchEmojiProvider(force?: boolean): Promise<EmojiRepository | undefined>;
  // (undocumented)
  filter(query?: string, options?: SearchOptions): void;
  // (undocumented)
  findByEmojiId(
    emojiId: EmojiId,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  // (undocumented)
  findById(
    id: string,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  // (undocumented)
  findByShortName(
    shortName: string,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  // (undocumented)
  findInCategory(categoryId: CategoryId): Promise<EmojiDescription[]>;
  // (undocumented)
  getAsciiMap(): Promise<Map<string, EmojiDescription>>;
  // (undocumented)
  getCurrentUser(): OptionalUser;
  // (undocumented)
  getFrequentlyUsed(options?: SearchOptions): Promise<EmojiDescription[]>;
  getMediaEmojiDescriptionURLWithInlineToken(
    emoji: EmojiDescription,
  ): Promise<EmojiDescription>;
  // (undocumented)
  getOptimisticImageURL: (emojiId: EmojiId) => string | undefined;
  // (undocumented)
  getSelectedTone(): ToneSelection;
  // (undocumented)
  protected initEmojiRepository(emojiResponses: EmojiResponse[]): void;
  // (undocumented)
  protected initSiteEmojiResource(
    emojiResponse: EmojiResponse,
    provider: ServiceConfig,
  ): Promise<void>;
  // (undocumented)
  protected isInitialised: boolean;
  // (undocumented)
  protected isLoaded: () => false | EmojiRepository | undefined;
  // (undocumented)
  protected lastQuery?: LastQuery;
  // (undocumented)
  loadMediaEmoji(
    emoji: EmojiDescription,
    useAlt?: boolean,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  // (undocumented)
  protected notifyResult(result: EmojiSearchResult): void;
  // (undocumented)
  optimisticMediaRendering(emoji: EmojiDescription, useAlt?: boolean): boolean;
  // (undocumented)
  protected recordConfig?: ServiceConfig;
  recordSelection(emoji: EmojiDescription): Promise<any>;
  // (undocumented)
  protected refreshLastFilter(): void;
  // (undocumented)
  protected retries: Map<Retry<any>, ResolveReject<any>>;
  // (undocumented)
  protected retryIfLoading<T>(retry: Retry<T>, defaultResponse: T): Promise<T>;
  // (undocumented)
  protected selectedTone: ToneSelection;
  // (undocumented)
  setSelectedTone(tone: ToneSelection): void;
  // (undocumented)
  protected siteEmojiResource?: SiteEmojiResource;
}

// @public (undocumented)
export interface EmojiResourceConfig {
  allowUpload?: boolean;
  currentUser?: User;
  optimisticImageApi?: OptimisticImageApiLoaderConfig;
  providers: ServiceConfig[];
  recordConfig?: ServiceConfig;
  singleEmojiApi?: SingleEmojiApiLoaderConfig;
}

// @public (undocumented)
export interface EmojiResponse {
  // (undocumented)
  emojis: EmojiDescriptionWithVariations[];
  // (undocumented)
  mediaApiToken?: MediaApiToken;
}

// @public (undocumented)
export interface EmojiSearchResult {
  // (undocumented)
  emojis: EmojiDescription[];
  // (undocumented)
  query?: string;
}

// @public (undocumented)
export interface EmojiServiceDescription {
  // (undocumented)
  altRepresentations?: AltRepresentations;
  // (undocumented)
  ascii?: string[];
  // (undocumented)
  category: string;
  // (undocumented)
  createdDate?: string;
  // (undocumented)
  creatorUserId?: string;
  // (undocumented)
  fallback?: string;
  // (undocumented)
  id: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  order?: number;
  // (undocumented)
  representation: EmojiServiceRepresentation;
  // (undocumented)
  searchable: boolean;
  // (undocumented)
  shortName: string;
  // (undocumented)
  type: string;
}

// @public (undocumented)
export interface EmojiServiceDescriptionWithVariations
  extends EmojiServiceDescription {
  // (undocumented)
  skinVariations?: EmojiServiceDescription[];
}

// @public (undocumented)
export type EmojiServiceRepresentation =
  | SpriteServiceRepresentation
  | ImageRepresentation;

// @public
export interface EmojiServiceResponse {
  // (undocumented)
  emojis: EmojiServiceDescriptionWithVariations[];
  // (undocumented)
  meta?: EmojiMeta;
}

// @public (undocumented)
export const emojiSprite = 'emoji-common-emoji-sprite';

// @public (undocumented)
export class EmojiTypeAhead extends LoadingEmojiComponent<Props_7, State> {
  constructor(props: Props_7);
  // (undocumented)
  asyncLoadComponent(): void;
  // (undocumented)
  static AsyncLoadedComponent?: ComponentClass<Props_8>;
  // (undocumented)
  chooseCurrentSelection: () => void;
  // (undocumented)
  count: () => number;
  // (undocumented)
  renderLoaded(
    loadedEmojiProvider: EmojiProvider,
    EmojiTypeAheadComponent: ComponentClass<Props_8>,
  ): JSX.Element | null;
  // (undocumented)
  selectNext: () => void;
  // (undocumented)
  selectPrevious: () => void;
  // (undocumented)
  state: {
    asyncLoadedComponent: React_2.ComponentClass<Props_8, any> | undefined;
  };
}

// @public (undocumented)
interface EmojiTypeAheadBaseProps {
  // (undocumented)
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  listLimit?: number;
  onClose?: OnLifecycle;
  onOpen?: OnLifecycle;
  onSelection?: OnEmojiEvent;
  query?: string;
}

// @public (undocumented)
export class EmojiTypeAheadItem extends PureComponent<Props_11, {}> {
  // (undocumented)
  onEmojiMenuItemMouseMove: React_2.MouseEventHandler<HTMLDivElement>;
  // (undocumented)
  onEmojiSelected: React_2.MouseEventHandler<HTMLDivElement>;
  // (undocumented)
  render(): JSX.Element;
}

// @public (undocumented)
export interface EmojiUpload {
  // (undocumented)
  dataURL: string;
  // (undocumented)
  filename: string;
  // (undocumented)
  height: number;
  // (undocumented)
  name: string;
  // (undocumented)
  shortName: string;
  // (undocumented)
  width: number;
}

// @public (undocumented)
export type EmojiUploader = EmojiUploaderInternal;

// @public (undocumented)
export const EmojiUploader: React_2.ForwardRefExoticComponent<
  Omit<Props_5, keyof WithAnalyticsEventsProps> & React_2.RefAttributes<any>
>;

// @public (undocumented)
class EmojiUploaderInternal extends LoadingEmojiComponent<Props_5, State> {
  constructor(props: Props_5);
  // (undocumented)
  asyncLoadComponent(): void;
  // (undocumented)
  static AsyncLoadedComponent?: FC<Props_6>;
  // (undocumented)
  renderLoaded(
    loadedEmojiProvider: EmojiProvider,
    EmojiUploadComponent: FC<Props_6>,
  ): JSX.Element;
  // (undocumented)
  state: {
    asyncLoadedComponent: React_2.FC<Props_6> | undefined;
  };
}

// @public
export interface EmojiVariationDescription extends EmojiDescription {
  baseId: string;
}

// @public (undocumented)
export interface ImageRepresentation extends EmojiImageRepresentation {
  // (undocumented)
  imagePath: string;
}

// @public (undocumented)
interface LastQuery {
  // (undocumented)
  options?: SearchOptions;
  // (undocumented)
  query?: string;
}

// @public
abstract class LoadingEmojiComponent<
  P extends Props_4,
  S extends State
> extends Component<P, S> {
  constructor(props: P, state: S);
  // (undocumented)
  abstract asyncLoadComponent(): void;
  // (undocumented)
  componentDidMount(): void;
  // (undocumented)
  componentWillUnmount(): void;
  // (undocumented)
  render(): JSX.Element | null;
  // (undocumented)
  abstract renderLoaded(
    loadedEmojiProvider: EmojiProvider,
    asyncLoadedComponent: ComponentType<any>,
  ): JSX.Element | null;
  // (undocumented)
  renderLoading(): JSX.Element | null;
  // (undocumented)
  protected setAsyncState(asyncLoadedComponent: ComponentType<any>): void;
  // (undocumented)
  UNSAFE_componentWillReceiveProps(nextProps: Readonly<P>): void;
}

// @public (undocumented)
export interface MediaApiRepresentation extends EmojiImageRepresentation {
  // (undocumented)
  mediaPath: string;
}

// @public
export interface MediaApiToken {
  // (undocumented)
  clientId: string;
  // (undocumented)
  collectionName: string;
  // (undocumented)
  expiresAt: number;
  // (undocumented)
  jwt: string;
  // (undocumented)
  url: string;
}

// @public (undocumented)
export type Message = React.ReactNode;

// @public (undocumented)
const messages: {
  deleteEmojiTitle: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  deleteEmojiDescription: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  deleteEmojiLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  addCustomEmojiLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiPlaceholder: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiNameAriaLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiChooseFileTitle: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiChooseFileScreenReaderDescription: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiSelectSkinToneButtonAriaLabelText: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiImageRequirements: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiPreviewTitle: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiPreview: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  addEmojiLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  retryLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  cancelLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  searchPlaceholder: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  searchLabel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  categoriesSearchResults: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  frequentCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  peopleCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  natureCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  foodsCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  activityCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  placesCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  objectsCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  symbolsCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  flagsCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  productivityCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  userUploadsCustomCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  allUploadsCustomCategory: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  deleteEmojiFailed: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiInvalidImage: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiUploadFailed: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  emojiImageTooBig: {
    id: string;
    defaultMessage: string;
    description: string;
  };
};

// @public (undocumented)
export interface OnCategory {
  // (undocumented)
  (categoryId: CategoryId | null): void;
}

// @public (undocumented)
export interface OnEmojiEvent<T = any> {
  // (undocumented)
  (
    emojiId: EmojiId,
    emoji: OptionalEmojiDescription,
    event?: SyntheticEvent<T>,
  ): void;
}

// @public (undocumented)
interface OnLifecycle {
  // (undocumented)
  (): void;
}

// @public (undocumented)
export interface OnToneSelected {
  // (undocumented)
  (variation: ToneValueType): void;
}

// @public (undocumented)
export interface OnToneSelectorCancelled {
  // (undocumented)
  (): void;
}

// @public (undocumented)
interface OptimisticImageApiLoaderConfig extends ServiceConfig {
  // (undocumented)
  getUrl: (emojiId: EmojiId) => string;
}

// @public (undocumented)
export type OptionalEmojiDescription = EmojiDescription | undefined;

// @public (undocumented)
export type OptionalEmojiDescriptionWithVariations =
  | EmojiDescriptionWithVariations
  | undefined;

// @public (undocumented)
export type OptionalUser = User | undefined;

// @public (undocumented)
interface PickerRefHandler {
  // (undocumented)
  (ref: any): any;
}

// @public (undocumented)
interface Props {
  className?: string;
  emoji: EmojiDescription;
  fitToHeight?: number;
  onDelete?: OnEmojiEvent;
  onLoadError?: OnEmojiEvent<HTMLImageElement>;
  onMouseMove?: OnEmojiEvent;
  onSelected?: OnEmojiEvent;
  selected?: boolean;
  selectOnHover?: boolean;
  // (undocumented)
  shouldBeInteractive?: boolean;
  showDelete?: boolean;
  showTooltip?: boolean;
}

// @public (undocumented)
interface Props_10 extends BaseResourcedEmojiProps {
  emojiProvider: EmojiResource_2;
}

// @public (undocumented)
interface Props_11 {
  // (undocumented)
  emoji: EmojiDescription;
  // (undocumented)
  onMouseMove: OnEmojiEvent;
  // (undocumented)
  onSelection: OnEmojiEvent;
  // (undocumented)
  selected: boolean;
}

// @public (undocumented)
interface Props_2 {
  // (undocumented)
  loading?: boolean;
  // (undocumented)
  representation?: EmojiImageRepresentation;
  // (undocumented)
  shortName: string;
  // (undocumented)
  showTooltip?: boolean;
  // (undocumented)
  size?: number;
}

// @public (undocumented)
interface Props_3 extends Props_4 {
  hideToneSelector?: boolean;
  onPickerRef?: PickerRefHandler;
  onSelection?: OnEmojiEvent;
}

// @public (undocumented)
interface Props_4 {
  emojiProvider: Promise<EmojiProvider>;
}

// @public (undocumented)
interface Props_5 extends Props_4 {
  // (undocumented)
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
}

// @public (undocumented)
interface Props_6 {
  // (undocumented)
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  // (undocumented)
  emojiProvider: EmojiProvider;
  // (undocumented)
  onUploaderRef?: UploadRefHandler;
}

// @public (undocumented)
interface Props_7 extends EmojiTypeAheadBaseProps, Props_4 {
  // (undocumented)
  offsetX?: number;
  // (undocumented)
  offsetY?: number;
  // (undocumented)
  position?: RelativePosition;
  target?: string | HTMLElement;
  // (undocumented)
  zIndex?: number | string;
}

// @public (undocumented)
interface Props_8 extends EmojiTypeAheadBaseProps {
  emojiProvider: EmojiProvider;
}

// @public (undocumented)
interface Props_9 extends BaseResourcedEmojiProps, Props_4 {}

// @public
interface QueueOptions {
  maxDuplicates: number;
  minUniqueItems: number;
}

// @public (undocumented)
export const recordSelectionFailedSli: (
  options?:
    | {
        createAnalyticsEvent?: CreateUIAnalyticsEvent | undefined;
      }
    | undefined,
) => (err: Error) => Promise<never>;

// @public (undocumented)
export const recordSelectionSucceededSli: (
  options?:
    | {
        createAnalyticsEvent?: CreateUIAnalyticsEvent | undefined;
      }
    | undefined,
) => () => void;

// @public (undocumented)
export type RelativePosition = 'above' | 'below' | 'auto';

// @public (undocumented)
interface ResolveReject<T> {
  // (undocumented)
  reject(reason?: any): void;
  // (undocumented)
  resolve(result: T): void;
}

// @public (undocumented)
export class ResourcedEmoji extends LoadingEmojiComponent<Props_9, State> {
  constructor(props: Props_9);
  // (undocumented)
  asyncLoadComponent(): void;
  // (undocumented)
  static AsyncLoadedComponent: FC<Props_10>;
  // (undocumented)
  componentWillUnmount(): void;
  // (undocumented)
  renderLoaded(
    loadedEmojiProvider: EmojiResource,
    ResourcedEmojiComponent: ComponentClass<Props_10>,
  ): JSX.Element;
  // (undocumented)
  renderLoading(): JSX.Element;
  // (undocumented)
  state: {
    asyncLoadedComponent: React_2.FC<Props_10>;
  };
}

// @public (undocumented)
interface Retry<T> {
  // (undocumented)
  (): Promise<T> | T;
}

// @public (undocumented)
type SamplingFunc = (rate: number) => boolean;

// @public (undocumented)
export interface SearchOptions {
  // (undocumented)
  limit?: number;
  // (undocumented)
  skinTone?: number;
  // (undocumented)
  sort?: SearchSort;
}

// @public (undocumented)
export enum SearchSort {
  // (undocumented)
  Default = 1,
  // (undocumented)
  None = 0,
  // (undocumented)
  UsageFrequency = 2,
}

// @public (undocumented)
export const selected = 'emoji-common-selected';

// @public (undocumented)
export const selectOnHover = 'emoji-common-select-on-hover';

// @public (undocumented)
interface SingleEmojiApiLoaderConfig extends ServiceConfig {
  // (undocumented)
  getUrl: (emojiId: EmojiId) => string;
}

// @public (undocumented)
class SiteEmojiResource {
  constructor(siteServiceConfig: ServiceConfig, mediaApiToken: MediaApiToken);
  deleteEmoji(emoji: EmojiDescription): Promise<boolean>;
  // (undocumented)
  findEmoji(emojiId: EmojiId): Promise<OptionalEmojiDescription>;
  generateTokenisedMediaURL(emoji: EmojiDescription): Promise<string>;
  hasUploadToken(): Promise<boolean>;
  loadMediaEmoji(
    emoji: EmojiDescription,
    useAlt?: boolean,
  ): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
  // (undocumented)
  optimisticRendering(
    emoji: EmojiDescription,
    useAlt?: boolean,
  ): boolean | Promise<boolean>;
  // (undocumented)
  prepareForUpload(): void;
  // (undocumented)
  protected tokenManager: TokenManager;
  // (undocumented)
  uploadEmoji(
    upload: EmojiUpload,
    retry?: boolean,
    progressCallback?: EmojiProgessCallback,
  ): Promise<EmojiDescription>;
}

// @public (undocumented)
export interface SpriteImageRepresentation extends EmojiImageRepresentation {
  // (undocumented)
  x: number;
  // (undocumented)
  xIndex: number;
  // (undocumented)
  y: number;
  // (undocumented)
  yIndex: number;
}

// @public
export interface SpriteRepresentation extends SpriteImageRepresentation {
  // (undocumented)
  sprite: SpriteSheet;
}

// @public
export interface SpriteServiceRepresentation extends SpriteImageRepresentation {
  spriteRef: string;
}

// @public (undocumented)
export interface SpriteSheet {
  // (undocumented)
  column: number;
  // (undocumented)
  height: number;
  // (undocumented)
  row: number;
  // (undocumented)
  url: string;
  // (undocumented)
  width: number;
}

// @public (undocumented)
export interface SpriteSheets {
  // (undocumented)
  [index: string]: SpriteSheet;
}

// @public (undocumented)
interface State {
  // (undocumented)
  asyncLoadedComponent?: ComponentType<any>;
  // (undocumented)
  loadedEmojiProvider?: EmojiProvider;
}

// @public (undocumented)
export interface Styles {
  // (undocumented)
  [index: string]: any;
}

// @public (undocumented)
export const toEmojiId: (emoji: EmojiDescription) => EmojiId;

// @public (undocumented)
class TokenManager {
  constructor(siteServiceConfig: ServiceConfig);
  // (undocumented)
  addToken(type: TokenType, mediaApiToken: MediaApiToken): void;
  // (undocumented)
  fetchNewToken(type: TokenType): Promise<MediaApiToken>;
  // (undocumented)
  getToken(type: TokenType, forceRefresh?: boolean): Promise<MediaApiToken>;
  // (undocumented)
  isValidToken(mediaApiToken: MediaApiToken): boolean;
}

// @public (undocumented)
type TokenType = 'read' | 'upload';

// @public (undocumented)
export type ToneSelection = number | undefined;

// @public (undocumented)
type ToneValueType = number;

// @public (undocumented)
export const toOptionalEmojiId: (
  emoji: OptionalEmojiDescription,
) => EmojiId | undefined;

// @public (undocumented)
export enum UfoComponentName {
  // (undocumented)
  EMOJI = 'emoji',
  // (undocumented)
  EMOJI_PICKER = 'emoji-picker',
  // (undocumented)
  EMOJI_PROVIDER = 'emoji-provider',
}

// @public (undocumented)
export enum UfoExperienceName {
  // (undocumented)
  EMOJI_PICKER_OPENED = 'emoji-picker-opened',
  // (undocumented)
  EMOJI_RENDERED = 'emoji-rendered',
  // (undocumented)
  EMOJI_RESOURCE_FETCHED = 'emoji-resource-fetched',
  // (undocumented)
  EMOJI_SEARCHED = 'emoji-searched',
  // (undocumented)
  EMOJI_SELECTION_RECORDED = 'emoji-selection-recorded',
  // (undocumented)
  EMOJI_UPLOADED = 'emoji-uploaded',
}

// @public (undocumented)
export const ufoExperiences: {
  'emoji-rendered': ConcurrentExperience;
  'emoji-resource-fetched': ConcurrentExperience;
  'emoji-picker-opened': UFOExperience;
  'emoji-selection-recorded': UFOExperience;
  'emoji-uploaded': UFOExperience;
  'emoji-searched': UFOExperience;
};

// @public (undocumented)
export interface UploadingEmojiProvider extends EmojiProvider {
  isUploadSupported(): Promise<boolean>;
  prepareForUpload(): Promise<void>;
  uploadCustomEmoji(
    upload: EmojiUpload,
    retry?: boolean,
  ): Promise<EmojiDescription>;
}

// @public (undocumented)
interface UploadRefHandler {
  // (undocumented)
  (ref: HTMLDivElement): void;
}

// @public
export class UsageFrequencyTracker {
  constructor(useStorageIfPossible?: boolean);
  clear(): void;
  getOrder(): Array<string>;
  // (undocumented)
  protected queue: DuplicateLimitedQueue<string>;
  recordUsage(emoji: EmojiDescription): void;
}

// @public (undocumented)
export const useEmojiContext: () => EmojiContextType;

// @public (undocumented)
export interface User {
  // (undocumented)
  id: string;
}

// @public
export const withSampling: (
  ufoExperience: UFOExperience,
) => WithSamplingUFOExperience;

// @public (undocumented)
export interface WithSamplingUFOExperience
  extends Omit<UFOExperience, 'start'> {
  // (undocumented)
  start: (options: {
    samplingRate: number;
    samplingFunc?: SamplingFunc;
    startTime?: number;
  }) => Promise<void>;
}

// (No @packageDocumentation comment for this package)
```
